// GLSL shader autogenerated by cg2glsl.py.
#if defined(VERTEX)

#if __VERSION__ >= 130
#define COMPAT_VARYING out
#define COMPAT_ATTRIBUTE in
#define COMPAT_TEXTURE texture
#else
#define COMPAT_VARYING varying 
#define COMPAT_ATTRIBUTE attribute 
#define COMPAT_TEXTURE texture2D
#endif

#ifdef GL_ES
#define COMPAT_PRECISION mediump
#else
#define COMPAT_PRECISION
#endif
COMPAT_VARYING     float _frame_rotation;
struct input_dummy {
    vec2 _video_size;
    vec2 _texture_size;
    vec2 _output_dummy_size;
    float _frame_count;
    float _frame_direction;
    float _frame_rotation;
};
vec4 _oPosition1;
input_dummy _IN1;
vec4 _r0008;
COMPAT_ATTRIBUTE vec4 VertexCoord;
COMPAT_ATTRIBUTE vec4 COLOR;
COMPAT_VARYING vec4 COL0;
COMPAT_ATTRIBUTE vec4 TexCoord;
COMPAT_VARYING vec4 TEX0;
COMPAT_ATTRIBUTE vec4 LUTTexCoord;
COMPAT_VARYING vec4 TEX1;
 
uniform mat4 MVPMatrix;
uniform int FrameDirection;
uniform int FrameCount;
uniform COMPAT_PRECISION vec2 OutputSize;
uniform COMPAT_PRECISION vec2 TextureSize;
uniform COMPAT_PRECISION vec2 InputSize;
void main()
{
    vec4 _oColor;
    vec2 _oTex;
    vec2 _otex_border;
    vec2 _scale;
    vec2 _middle;
    vec2 _diff;
    vec2 _dist;
    _r0008 = VertexCoord.x*MVPMatrix[0];
    _r0008 = _r0008 + VertexCoord.y*MVPMatrix[1];
    _r0008 = _r0008 + VertexCoord.z*MVPMatrix[2];
    _r0008 = _r0008 + VertexCoord.w*MVPMatrix[3];
    _oPosition1 = _r0008;
    _oColor = COLOR;
    _scale = (OutputSize/vec2( 3.20000000E+02, 2.40000000E+02))/6.00000000E+00;
    _middle = (5.00000000E-01*InputSize)/TextureSize;
    _diff = TexCoord.xy - _middle;
    _oTex = _middle + _diff*_scale;
    _dist = LUTTexCoord.xy - vec2( 4.99989986E-01, 4.99989986E-01);
    _otex_border = vec2( 4.99989986E-01, 4.99989986E-01) + (_dist*OutputSize)/vec2( 2.56000000E+03, 1.44000000E+03);
    gl_Position = _r0008;
    COL0 = COLOR;
    TEX0.xy = _oTex;
    TEX1.xy = _otex_border;
} 
#elif defined(FRAGMENT)

#if __VERSION__ >= 130
#define COMPAT_VARYING in
#define COMPAT_TEXTURE texture
out vec4 FragColor;
#else
#define COMPAT_VARYING varying
#define FragColor gl_FragColor
#define COMPAT_TEXTURE texture2D
#endif

#ifdef GL_ES
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
#define COMPAT_PRECISION mediump
#else
#define COMPAT_PRECISION
#endif
COMPAT_VARYING     float _frame_rotation;
struct input_dummy {
    vec2 _video_size;
    vec2 _texture_size;
    vec2 _output_dummy_size;
    float _frame_count;
    float _frame_direction;
    float _frame_rotation;
};
vec4 _ret_0;
vec4 _TMP25;
float _TMP24;
float _TMP23;
float _TMP22;
float _TMP30;
float _TMP29;
float _TMP28;
float _TMP21;
float _TMP20;
float _TMP19;
float _TMP18;
float _TMP35;
float _TMP34;
float _TMP31;
float _TMP33;
float _TMP32;
vec2 _TMP16;
vec2 _TMP15;
float _TMP27;
float _TMP26;
vec2 _TMP14;
float _TMP13;
vec2 _TMP11;
vec2 _TMP10;
vec2 _TMP9;
float _TMP8;
vec2 _TMP6;
vec2 _TMP5;
vec2 _TMP4;
float _TMP3;
uniform sampler2D Texture;
uniform sampler2D bg;
input_dummy _IN1;
vec2 _x0046;
vec2 _x0052;
vec2 _x0058;
vec2 _a0064;
vec2 _b0064;
float _y0066;
float _x0066;
float _t30068;
float _t10068;
float _t00068;
float _t40068;
vec2 _x0084;
vec2 _x0090;
vec2 _x0096;
vec2 _a0102;
vec2 _b0102;
float _y0104;
float _x0104;
float _t30106;
float _t10106;
float _t00106;
float _t40106;
vec2 _x0122;
vec2 _x0128;
vec2 _x0134;
vec2 _a0140;
vec2 _b0140;
float _y0142;
float _x0142;
float _t30144;
float _t10144;
float _t00144;
float _t40144;
vec3 _TMP159;
float _a0164;
float _x0168;
float _TMP169;
vec3 _TMP175;
vec3 _v0182;
float _TMP189;
float _x0190;
COMPAT_VARYING vec4 TEX0;
COMPAT_VARYING vec4 TEX1;
 
uniform int FrameDirection;
uniform int FrameCount;
uniform COMPAT_PRECISION vec2 OutputSize;
uniform COMPAT_PRECISION vec2 TextureSize;
uniform COMPAT_PRECISION vec2 InputSize;
void main()
{
    vec2 _pc;
    vec2 _pa;
    vec2 _pb;
    vec2 _zc;
    vec3 _fc;
    int _i1;
    float _d1;
    vec2 _za;
    vec3 _fa;
    int _i2;
    float _d2;
    vec2 _zb;
    vec3 _fb;
    int _i3;
    float _d3;
    vec3 _col;
    vec3 _nor;
    vec4 _effect;
    vec4 _frame;
    vec4 _background;
    _TMP3 = min(TextureSize.y, TextureSize.x);
    _pc = (2.00000000E+03*(TEX0.xy*(TextureSize.xy/InputSize.xy)).xy - TextureSize.xy)/_TMP3;
    _pa = _pc + vec2( 3.99999991E-02, 0.00000000E+00);
    _pb = _pc + vec2( 0.00000000E+00, 3.99999991E-02);
    _zc = _pc;
    _fc = vec3( 0.00000000E+00, 0.00000000E+00, 0.00000000E+00);
    _i1 = 0;
    for (; _i1 < 8; _i1 = _i1 + 1) { 
        _x0046 = _zc.yx + float(FrameCount)*9.99999978E-03*5.00000000E+00;
        _TMP26 = cos(_x0046.x);
        _TMP27 = cos(_x0046.y);
        _TMP4 = vec2(_TMP26, _TMP27);
        _x0052 = _zc.yx + _TMP4;
        _TMP26 = cos(_x0052.x);
        _TMP27 = cos(_x0052.y);
        _TMP5 = vec2(_TMP26, _TMP27);
        _x0058 = _zc.yx + _TMP5;
        _TMP26 = cos(_x0058.x);
        _TMP27 = cos(_x0058.y);
        _TMP6 = vec2(_TMP26, _TMP27);
        _zc = _zc + _TMP6;
        _a0064 = _zc - _pc;
        _b0064 = _zc - _pc;
        _d1 = dot(_a0064, _b0064);
        _fc.x = _fc.x + 1.00000000E+00/(1.00000000E+00 + _d1);
        _fc.y = _fc.y + _d1;
        _y0066 = _zc.y - _pc.y;
        _x0066 = _zc.x - _pc.x;
        _t30068 = abs(_x0066);
        _t10068 = abs(_y0066);
        _t00068 = max(_t30068, _t10068);
        _t10068 = min(_t30068, _t10068);
        _t30068 = 1.00000000E+00/_t00068;
        _t30068 = _t10068*_t30068;
        _t40068 = _t30068*_t30068;
        _t00068 = -1.34804696E-02*_t40068 + 5.74773103E-02;
        _t00068 = _t00068*_t40068 - 1.21239103E-01;
        _t00068 = _t00068*_t40068 + 1.95635900E-01;
        _t00068 = _t00068*_t40068 - 3.32994610E-01;
        _t00068 = _t00068*_t40068 + 9.99995589E-01;
        _t30068 = _t00068*_t30068;
        _TMP32 = abs(_y0066);
        _TMP33 = abs(_x0066);
        if (_TMP32 > _TMP33) { 
            _TMP31 = 1.57079601E+00 - _t30068;
        } else {
            _TMP31 = _t30068;
        } 
        if (_x0066 < 0.00000000E+00) { 
            _TMP34 = 3.14159298E+00 - _TMP31;
        } else {
            _TMP34 = _TMP31;
        } 
        if (_y0066 < 0.00000000E+00) { 
            _TMP35 = -_TMP34;
        } else {
            _TMP35 = _TMP34;
        } 
        _TMP8 = sin(_TMP35);
        _fc.z = _fc.z + _TMP8;
    } 
    _fc = _fc/8.00000000E+00;
    _za = _pa;
    _fa = vec3( 0.00000000E+00, 0.00000000E+00, 0.00000000E+00);
    _i2 = 0;
    for (; _i2 < 8; _i2 = _i2 + 1) { 
        _x0084 = _za.yx + float(FrameCount)*9.99999978E-03*5.00000000E+00;
        _TMP26 = cos(_x0084.x);
        _TMP27 = cos(_x0084.y);
        _TMP9 = vec2(_TMP26, _TMP27);
        _x0090 = _za.yx + _TMP9;
        _TMP26 = cos(_x0090.x);
        _TMP27 = cos(_x0090.y);
        _TMP10 = vec2(_TMP26, _TMP27);
        _x0096 = _za.yx + _TMP10;
        _TMP26 = cos(_x0096.x);
        _TMP27 = cos(_x0096.y);
        _TMP11 = vec2(_TMP26, _TMP27);
        _za = _za + _TMP11;
        _a0102 = _za - _pa;
        _b0102 = _za - _pa;
        _d2 = dot(_a0102, _b0102);
        _fa.x = _fa.x + 1.00000000E+00/(1.00000000E+00 + _d2);
        _fa.y = _fa.y + _d2;
        _y0104 = _za.y - _pa.y;
        _x0104 = _za.x - _pa.x;
        _t30106 = abs(_x0104);
        _t10106 = abs(_y0104);
        _t00106 = max(_t30106, _t10106);
        _t10106 = min(_t30106, _t10106);
        _t30106 = 1.00000000E+00/_t00106;
        _t30106 = _t10106*_t30106;
        _t40106 = _t30106*_t30106;
        _t00106 = -1.34804696E-02*_t40106 + 5.74773103E-02;
        _t00106 = _t00106*_t40106 - 1.21239103E-01;
        _t00106 = _t00106*_t40106 + 1.95635900E-01;
        _t00106 = _t00106*_t40106 - 3.32994610E-01;
        _t00106 = _t00106*_t40106 + 9.99995589E-01;
        _t30106 = _t00106*_t30106;
        _TMP32 = abs(_y0104);
        _TMP33 = abs(_x0104);
        if (_TMP32 > _TMP33) { 
            _TMP31 = 1.57079601E+00 - _t30106;
        } else {
            _TMP31 = _t30106;
        } 
        if (_x0104 < 0.00000000E+00) { 
            _TMP34 = 3.14159298E+00 - _TMP31;
        } else {
            _TMP34 = _TMP31;
        } 
        if (_y0104 < 0.00000000E+00) { 
            _TMP35 = -_TMP34;
        } else {
            _TMP35 = _TMP34;
        } 
        _TMP13 = sin(_TMP35);
        _fa.z = _fa.z + _TMP13;
    } 
    _fa = _fa/8.00000000E+00;
    _zb = _pb;
    _fb = vec3( 0.00000000E+00, 0.00000000E+00, 0.00000000E+00);
    _i3 = 0;
    for (; _i3 < 8; _i3 = _i3 + 1) { 
        _x0122 = _zb.yx + float(FrameCount)*9.99999978E-03*5.00000000E+00;
        _TMP26 = cos(_x0122.x);
        _TMP27 = cos(_x0122.y);
        _TMP14 = vec2(_TMP26, _TMP27);
        _x0128 = _zb.yx + _TMP14;
        _TMP26 = cos(_x0128.x);
        _TMP27 = cos(_x0128.y);
        _TMP15 = vec2(_TMP26, _TMP27);
        _x0134 = _zb.yx + _TMP15;
        _TMP26 = cos(_x0134.x);
        _TMP27 = cos(_x0134.y);
        _TMP16 = vec2(_TMP26, _TMP27);
        _zb = _zb + _TMP16;
        _a0140 = _zb - _pb;
        _b0140 = _zb - _pb;
        _d3 = dot(_a0140, _b0140);
        _fb.x = _fb.x + 1.00000000E+00/(1.00000000E+00 + _d3);
        _fb.y = _fb.y + _d3;
        _y0142 = _zb.y - _pb.y;
        _x0142 = _zb.x - _pb.x;
        _t30144 = abs(_x0142);
        _t10144 = abs(_y0142);
        _t00144 = max(_t30144, _t10144);
        _t10144 = min(_t30144, _t10144);
        _t30144 = 1.00000000E+00/_t00144;
        _t30144 = _t10144*_t30144;
        _t40144 = _t30144*_t30144;
        _t00144 = -1.34804696E-02*_t40144 + 5.74773103E-02;
        _t00144 = _t00144*_t40144 - 1.21239103E-01;
        _t00144 = _t00144*_t40144 + 1.95635900E-01;
        _t00144 = _t00144*_t40144 - 3.32994610E-01;
        _t00144 = _t00144*_t40144 + 9.99995589E-01;
        _t30144 = _t00144*_t30144;
        _TMP32 = abs(_y0142);
        _TMP33 = abs(_x0142);
        if (_TMP32 > _TMP33) { 
            _TMP31 = 1.57079601E+00 - _t30144;
        } else {
            _TMP31 = _t30144;
        } 
        if (_x0142 < 0.00000000E+00) { 
            _TMP34 = 3.14159298E+00 - _TMP31;
        } else {
            _TMP34 = _TMP31;
        } 
        if (_y0142 < 0.00000000E+00) { 
            _TMP35 = -_TMP34;
        } else {
            _TMP35 = _TMP34;
        } 
        _TMP18 = sin(_TMP35);
        _fb.z = _fb.z + _TMP18;
    } 
    _fb = _fb/8.00000000E+00;
    _TMP159 = vec3( 7.99999982E-02, 1.99999996E-02, 1.50000006E-01) + _fc.x*vec3( 5.20000041E-01, 1.08000004E+00, 1.45000005E+00);
    _a0164 = 9.99999978E-03*float(FrameCount)*5.00000000E+00;
    _TMP19 = cos(_a0164);
    _x0168 = _TMP19 - -5.00000000E-01;
    _TMP30 = min(1.00000000E+00, _x0168);
    _TMP169 = max(0.00000000E+00, _TMP30);
    _TMP20 = _TMP169*_TMP169*(3.00000000E+00 - 2.00000000E+00*_TMP169);
    _TMP175 = _TMP159 + _TMP20*(_TMP159.zxy - _TMP159);
    _col = _TMP175*(1.50000006E-01*_fc.y);
    _TMP21 = abs(_fc.z);
    _col = _col + (4.00000006E-01*_TMP21 - 1.00000001E-01);
    _v0182 = vec3(_fa.x - _fc.x, 9.99999978E-03, _fb.x - _fc.x);
    _TMP28 = dot(_v0182, _v0182);
    _TMP29 = inversesqrt(_TMP28);
    _nor = _TMP29*_v0182;
    _TMP22 = dot(_nor, vec3( 5.77300012E-01, 5.77300012E-01, 5.77300012E-01));
    _x0190 = 5.00000000E-01 + 5.00000000E-01*_TMP22;
    _TMP30 = min(1.00000000E+00, _x0190);
    _TMP189 = max(0.00000000E+00, _TMP30);
    _col = _col*(1.00000000E+00 + (6.99999988E-01*_TMP189)*_col);
    _TMP23 = pow(_nor.y, 1.28000000E+02);
    _col = _col + 3.00000012E-01*_TMP23;
    _TMP24 = length(_pc);
    _col = _col*(1.00000000E+00 - 1.00000001E-01*_TMP24);
    _effect = vec4(_col.x, _col.y, _col.z, 1.00000000E+00);
    _frame = COMPAT_TEXTURE(Texture, TEX0.xy);
    _TMP25 = COMPAT_TEXTURE(bg, TEX1.xy);
    _background = vec4(_TMP25.x, _TMP25.y, _TMP25.z, _TMP25.w);
    _ret_0 = _frame + _background.w*(_effect - _frame);
    FragColor = _ret_0;
    return;
} 
#endif
