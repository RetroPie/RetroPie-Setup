// GLSL shader autogenerated by cg2glsl.py.
#if defined(VERTEX)

#if __VERSION__ >= 130
#define COMPAT_VARYING out
#define COMPAT_ATTRIBUTE in
#define COMPAT_TEXTURE texture
#else
#define COMPAT_VARYING varying 
#define COMPAT_ATTRIBUTE attribute 
#define COMPAT_TEXTURE texture2D
#endif

#ifdef GL_ES
#define COMPAT_PRECISION mediump
#else
#define COMPAT_PRECISION
#endif
COMPAT_VARYING     float _frame_rotation;
struct input_dummy {
    vec2 _video_size;
    vec2 _texture_size;
    vec2 _output_dummy_size;
    float _frame_count;
    float _frame_direction;
    float _frame_rotation;
};
vec4 _oPosition1;
vec4 _r0005;
COMPAT_ATTRIBUTE vec4 VertexCoord;
COMPAT_ATTRIBUTE vec4 TexCoord;
COMPAT_VARYING vec4 TEX0;
 
uniform mat4 MVPMatrix;
uniform int FrameDirection;
uniform int FrameCount;
uniform COMPAT_PRECISION vec2 OutputSize;
uniform COMPAT_PRECISION vec2 TextureSize;
uniform COMPAT_PRECISION vec2 InputSize;
void main()
{
    vec2 _oTex;
    _r0005 = VertexCoord.x*MVPMatrix[0];
    _r0005 = _r0005 + VertexCoord.y*MVPMatrix[1];
    _r0005 = _r0005 + VertexCoord.z*MVPMatrix[2];
    _r0005 = _r0005 + VertexCoord.w*MVPMatrix[3];
    _oPosition1 = _r0005;
    _oTex = TexCoord.xy;
    gl_Position = _r0005;
    TEX0.xy = TexCoord.xy;
} 
#elif defined(FRAGMENT)

#if __VERSION__ >= 130
#define COMPAT_VARYING in
#define COMPAT_TEXTURE texture
out vec4 FragColor;
#else
#define COMPAT_VARYING varying
#define FragColor gl_FragColor
#define COMPAT_TEXTURE texture2D
#endif

#ifdef GL_ES
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
#define COMPAT_PRECISION mediump
#else
#define COMPAT_PRECISION
#endif
COMPAT_VARYING     float _frame_rotation;
struct input_dummy {
    vec2 _video_size;
    vec2 _texture_size;
    vec2 _output_dummy_size;
    float _frame_count;
    float _frame_direction;
    float _frame_rotation;
};
vec4 _ret_0;
vec3 _TMP43;
float _TMP39;
float _TMP35;
float _TMP32;
float _TMP29;
float _TMP27;
float _TMP23;
float _TMP20;
float _TMP17;
float _TMP15;
float _TMP11;
float _TMP8;
float _TMP5;
float _TMP38;
float _TMP37;
float _TMP36;
float _TMP34;
float _TMP33;
float _TMP31;
float _TMP30;
float _TMP28;
float _TMP26;
float _TMP25;
float _TMP24;
float _TMP22;
float _TMP21;
float _TMP19;
float _TMP18;
float _TMP16;
float _TMP14;
float _TMP13;
float _TMP12;
float _TMP10;
float _TMP9;
float _TMP7;
float _TMP6;
float _TMP4;
vec4 _TMP3;
uniform sampler2D Texture;
input_dummy _IN1;
float _TMP48;
float _x0049;
vec2 _c0061;
float _a0065;
float _b0065;
float _a0069;
float _b0069;
float _a0071;
float _a0075;
float _b0075;
float _b0077;
float _a0081;
float _b0081;
float _b0083;
float _a0085;
float _a0089;
float _b0089;
float _a0093;
float _b0093;
float _a0095;
float _a0099;
float _b0099;
float _b0101;
float _a0105;
float _b0105;
float _b0107;
float _a0109;
float _a0113;
float _b0113;
float _a0117;
float _b0117;
float _a0119;
float _a0123;
float _b0123;
float _b0125;
float _a0129;
float _b0129;
float _b0131;
float _a0133;
vec3 _r0137;
vec3 _TMP138;
COMPAT_VARYING vec4 TEX0;
 
uniform int FrameDirection;
uniform int FrameCount;
uniform COMPAT_PRECISION vec2 OutputSize;
uniform COMPAT_PRECISION vec2 TextureSize;
uniform COMPAT_PRECISION vec2 InputSize;
void main()
{
    vec3 _tempColor;
    float _X;
    float _i;
    _x0049 = TEX0.x*TextureSize.x - 5.00000000E-01;
    _TMP48 = fract(_x0049);
    _tempColor = vec3( 0.00000000E+00, 0.00000000E+00, 0.00000000E+00);
    _i = -6.00000000E+00;
    for (; _i < 8.00000000E+00; _i = _i + 1.00000000E+00) { 
        _X = _TMP48 - _i;
        _c0061 = vec2(TEX0.x - _X/TextureSize.x, TEX0.y);
        _TMP3 = COMPAT_TEXTURE(Texture, _c0061);
        _TMP4 = abs(_X);
        _a0065 = _TMP4 + 5.00000000E-01;
        _b0065 = 1.00000000E+00/(2.56000000E+02/InputSize.x);
        _TMP5 = min(_a0065, _b0065);
        _TMP6 = abs(_X);
        _a0069 = _TMP6 + 5.00000000E-01;
        _b0069 = 1.00000000E+00/(2.56000000E+02/InputSize.x);
        _TMP7 = min(_a0069, _b0069);
        _a0071 = 3.14159274E+00*(2.56000000E+02/InputSize.x)*_TMP7;
        _TMP8 = sin(_a0071);
        _TMP9 = abs(_X);
        _a0075 = _TMP9 - 5.00000000E-01;
        _b0075 = -1.00000000E+00/(2.56000000E+02/InputSize.x);
        _TMP10 = max(_a0075, _b0075);
        _b0077 = 1.00000000E+00/(2.56000000E+02/InputSize.x);
        _TMP11 = min(_TMP10, _b0077);
        _TMP12 = abs(_X);
        _a0081 = _TMP12 - 5.00000000E-01;
        _b0081 = -1.00000000E+00/(2.56000000E+02/InputSize.x);
        _TMP13 = max(_a0081, _b0081);
        _b0083 = 1.00000000E+00/(2.56000000E+02/InputSize.x);
        _TMP14 = min(_TMP13, _b0083);
        _a0085 = 3.14159274E+00*(2.56000000E+02/InputSize.x)*_TMP14;
        _TMP15 = sin(_a0085);
        _TMP16 = abs(_X);
        _a0089 = _TMP16 + 5.00000000E-01;
        _b0089 = 1.00000000E+00/(8.30000000E+01/InputSize.x);
        _TMP17 = min(_a0089, _b0089);
        _TMP18 = abs(_X);
        _a0093 = _TMP18 + 5.00000000E-01;
        _b0093 = 1.00000000E+00/(8.30000000E+01/InputSize.x);
        _TMP19 = min(_a0093, _b0093);
        _a0095 = 3.14159274E+00*(8.30000000E+01/InputSize.x)*_TMP19;
        _TMP20 = sin(_a0095);
        _TMP21 = abs(_X);
        _a0099 = _TMP21 - 5.00000000E-01;
        _b0099 = -1.00000000E+00/(8.30000000E+01/InputSize.x);
        _TMP22 = max(_a0099, _b0099);
        _b0101 = 1.00000000E+00/(8.30000000E+01/InputSize.x);
        _TMP23 = min(_TMP22, _b0101);
        _TMP24 = abs(_X);
        _a0105 = _TMP24 - 5.00000000E-01;
        _b0105 = -1.00000000E+00/(8.30000000E+01/InputSize.x);
        _TMP25 = max(_a0105, _b0105);
        _b0107 = 1.00000000E+00/(8.30000000E+01/InputSize.x);
        _TMP26 = min(_TMP25, _b0107);
        _a0109 = 3.14159274E+00*(8.30000000E+01/InputSize.x)*_TMP26;
        _TMP27 = sin(_a0109);
        _TMP28 = abs(_X);
        _a0113 = _TMP28 + 5.00000000E-01;
        _b0113 = 1.00000000E+00/(2.50000000E+01/InputSize.x);
        _TMP29 = min(_a0113, _b0113);
        _TMP30 = abs(_X);
        _a0117 = _TMP30 + 5.00000000E-01;
        _b0117 = 1.00000000E+00/(2.50000000E+01/InputSize.x);
        _TMP31 = min(_a0117, _b0117);
        _a0119 = 3.14159274E+00*(2.50000000E+01/InputSize.x)*_TMP31;
        _TMP32 = sin(_a0119);
        _TMP33 = abs(_X);
        _a0123 = _TMP33 - 5.00000000E-01;
        _b0123 = -1.00000000E+00/(2.50000000E+01/InputSize.x);
        _TMP34 = max(_a0123, _b0123);
        _b0125 = 1.00000000E+00/(2.50000000E+01/InputSize.x);
        _TMP35 = min(_TMP34, _b0125);
        _TMP36 = abs(_X);
        _a0129 = _TMP36 - 5.00000000E-01;
        _b0129 = -1.00000000E+00/(2.50000000E+01/InputSize.x);
        _TMP37 = max(_a0129, _b0129);
        _b0131 = 1.00000000E+00/(2.50000000E+01/InputSize.x);
        _TMP38 = min(_TMP37, _b0131);
        _a0133 = 3.14159274E+00*(2.50000000E+01/InputSize.x)*_TMP38;
        _TMP39 = sin(_a0133);
        _tempColor = _tempColor + vec3(_TMP3.x*((((3.14159274E+00*(2.56000000E+02/InputSize.x)*_TMP5 + _TMP8) - 3.14159274E+00*(2.56000000E+02/InputSize.x)*_TMP11) - _TMP15)/6.28318548E+00), _TMP3.y*((((3.14159274E+00*(8.30000000E+01/InputSize.x)*_TMP17 + _TMP20) - 3.14159274E+00*(8.30000000E+01/InputSize.x)*_TMP23) - _TMP27)/6.28318548E+00), _TMP3.z*((((3.14159274E+00*(2.50000000E+01/InputSize.x)*_TMP29 + _TMP32) - 3.14159274E+00*(2.50000000E+01/InputSize.x)*_TMP35) - _TMP39)/6.28318548E+00));
    } 
    _r0137 = _tempColor.xxx + _tempColor.y*vec3( 9.56300020E-01, -2.72100002E-01, -1.10699999E+00);
    _r0137 = _r0137 + _tempColor.z*vec3( 6.20999992E-01, -6.47400022E-01, 1.70459998E+00);
    _TMP43 = min(vec3( 1.00000000E+00, 1.00000000E+00, 1.00000000E+00), _r0137);
    _TMP138 = max(vec3( 0.00000000E+00, 0.00000000E+00, 0.00000000E+00), _TMP43);
    _ret_0 = vec4(_TMP138.x, _TMP138.y, _TMP138.z, 1.00000000E+00);
    FragColor = _ret_0;
    return;
} 
#endif
