// GLSL shader autogenerated by cg2glsl.py.
#if defined(VERTEX)

#if __VERSION__ >= 130
#define COMPAT_VARYING out
#define COMPAT_ATTRIBUTE in
#define COMPAT_TEXTURE texture
#else
#define COMPAT_VARYING varying 
#define COMPAT_ATTRIBUTE attribute 
#define COMPAT_TEXTURE texture2D
#endif

#ifdef GL_ES
#define COMPAT_PRECISION mediump
#else
#define COMPAT_PRECISION
#endif
COMPAT_VARYING     vec2 _input_dummy_tiles_per_texture1;
COMPAT_VARYING     vec2 _tile_size_uv1;
COMPAT_VARYING     vec2 _src_dxdy;
COMPAT_VARYING     vec2 _resize_magnification_scale;
COMPAT_VARYING     vec2 _tile_uv_wrap1;
COMPAT_VARYING     vec2 _src_tex_uv_wrap1;
COMPAT_VARYING     vec4 _position1;
COMPAT_VARYING     float _frame_rotation;
struct input_dummy {
    vec2 _video_size;
    vec2 _texture_size;
    vec2 _output_dummy_size;
    float _frame_count;
    float _frame_direction;
    float _frame_rotation;
};
struct out_vertex {
    vec4 _position1;
    vec2 _src_tex_uv_wrap1;
    vec2 _tile_uv_wrap1;
    vec2 _resize_magnification_scale;
    vec2 _src_dxdy;
    vec2 _tile_size_uv1;
    vec2 _input_dummy_tiles_per_texture1;
};
out_vertex _ret_0;
float _TMP14;
float _TMP22;
float _TMP21;
float _TMP20;
float _TMP19;
vec2 _TMP23;
float _TMP17;
float _TMP15;
float _TMP16;
input_dummy _IN1;
float _TMP140;
float _TMP146;
float _TMP152;
float _TMP158;
vec4 _r0237;
vec2 _TMP238;
float _desired_tile_size_x0239;
float _temp_tile_size_x0239;
vec2 _max_tile_size0239;
vec2 _reclamped_tile_size0239;
vec2 _final_resized_tile_size0239;
bool _TMP240;
float _b0242;
vec2 _TMP247;
vec2 _x0264;
COMPAT_ATTRIBUTE vec4 VertexCoord;
COMPAT_ATTRIBUTE vec4 TexCoord;
COMPAT_VARYING vec4 TEX0;
COMPAT_VARYING vec4 TEX1;
COMPAT_VARYING vec4 TEX2;
COMPAT_VARYING vec4 TEX3;
COMPAT_VARYING vec4 TEX4;
COMPAT_VARYING vec4 TEX5;
float _mask_min_allowed_tile_size;
 
uniform mat4 MVPMatrix;
uniform int FrameDirection;
uniform int FrameCount;
uniform COMPAT_PRECISION vec2 OutputSize;
uniform COMPAT_PRECISION vec2 TextureSize;
uniform COMPAT_PRECISION vec2 InputSize;
void main()
{
    out_vertex _OUT;
    vec2 _estimated_viewport_size1;
    vec2 _output_dummy_tiles_this_pass;
    vec2 _output_dummy_video_uv;
    vec2 _tile_uv_wrap;
    vec2 _input_dummy_tile_size;
    vec2 _tile_size_uv;
    vec2 _input_dummy_tiles_per_texture;
    vec2 _src_tex_uv_wrap;
    _TMP16 = min(2.00000000E+00, 0.00000000E+00);
    _TMP140 = max(0.00000000E+00, _TMP16);
    _TMP16 = min(1.00000000E+00, 0.00000000E+00);
    _TMP146 = max(0.00000000E+00, _TMP16);
    _TMP16 = min(1.80000000E+01, 3.00000000E+00);
    _TMP152 = max(1.00000000E+00, _TMP16);
    _TMP16 = min(1.92000000E+03, 4.80000000E+02);
    _TMP158 = max(3.42000000E+02, _TMP16);
    _TMP15 = floor(-1.60000000E+01);
    _mask_min_allowed_tile_size = -_TMP15;
    _r0237 = VertexCoord.x*MVPMatrix[0];
    _r0237 = _r0237 + VertexCoord.y*MVPMatrix[1];
    _r0237 = _r0237 + VertexCoord.z*MVPMatrix[2];
    _r0237 = _r0237 + VertexCoord.w*MVPMatrix[3];
    _estimated_viewport_size1 = OutputSize/vec2( 6.25000000E-02, 6.25000000E-02);
    _TMP240 = true;
    _b0242 = _estimated_viewport_size1.x/_TMP158;
    _TMP17 = _TMP152 + _TMP146*(_b0242 - _TMP152);
    _desired_tile_size_x0239 = 8.00000000E+00*_TMP17;
    if (_TMP140 > 5.00000000E-01) { 
        _TMP238 = vec2(_desired_tile_size_x0239, _desired_tile_size_x0239);
        _TMP240 = false;
    } 
    if (_TMP240) { 
        _temp_tile_size_x0239 = min(_desired_tile_size_x0239, 6.40000000E+01);
        _max_tile_size0239 = OutputSize/2.00000000E+00;
        _TMP23 = min(_max_tile_size0239, vec2(_temp_tile_size_x0239, _temp_tile_size_x0239));
        _TMP247 = max(vec2(_mask_min_allowed_tile_size, _mask_min_allowed_tile_size), _TMP23);
        _TMP19 = min(_TMP247.x, _TMP247.y);
        _TMP20 = min(_TMP247.y, _TMP247.y);
        _reclamped_tile_size0239 = vec2(_TMP19, _TMP20);
        _TMP21 = abs(0.00000000E+00);
        _TMP22 = max(_TMP21, 1.52587891E-05);
        _x0264 = _reclamped_tile_size0239 + vec2(_TMP22, _TMP22);
        _final_resized_tile_size0239 = floor(_x0264);
        _TMP238 = _final_resized_tile_size0239;
    } 
    _output_dummy_tiles_this_pass = OutputSize/_TMP238;
    _output_dummy_video_uv = (TexCoord.xy*TextureSize)/InputSize;
    _tile_uv_wrap = _output_dummy_video_uv*_output_dummy_tiles_this_pass;
    _TMP14 = min(6.40000000E+01, InputSize.x);
    _input_dummy_tile_size = vec2(_TMP14, _TMP238.y);
    _tile_size_uv = _input_dummy_tile_size/TextureSize;
    _input_dummy_tiles_per_texture = TextureSize/_input_dummy_tile_size;
    _src_tex_uv_wrap = _tile_uv_wrap*_tile_size_uv;
    _OUT._resize_magnification_scale = _TMP238/_input_dummy_tile_size;
    _OUT._src_dxdy = vec2(1.00000000E+00/TextureSize.x, 0.00000000E+00);
    _ret_0._position1 = _r0237;
    _ret_0._src_tex_uv_wrap1 = _src_tex_uv_wrap;
    _ret_0._tile_uv_wrap1 = _tile_uv_wrap;
    _ret_0._resize_magnification_scale = _OUT._resize_magnification_scale;
    _ret_0._src_dxdy = _OUT._src_dxdy;
    _ret_0._tile_size_uv1 = _tile_size_uv;
    _ret_0._input_dummy_tiles_per_texture1 = _input_dummy_tiles_per_texture;
    gl_Position = _r0237;
    TEX0.xy = _src_tex_uv_wrap;
    TEX1.xy = _tile_uv_wrap;
    TEX2.xy = _OUT._resize_magnification_scale;
    TEX3.xy = _OUT._src_dxdy;
    TEX4.xy = _tile_size_uv;
    TEX5.xy = _input_dummy_tiles_per_texture;
    return;
    TEX0.xy = _ret_0._src_tex_uv_wrap1;
    TEX1.xy = _ret_0._tile_uv_wrap1;
    TEX2.xy = _ret_0._resize_magnification_scale;
    TEX3.xy = _ret_0._src_dxdy;
    TEX4.xy = _ret_0._tile_size_uv1;
    TEX5.xy = _ret_0._input_dummy_tiles_per_texture1;
} 
#elif defined(FRAGMENT)

#if __VERSION__ >= 130
#define COMPAT_VARYING in
#define COMPAT_TEXTURE texture
out vec4 FragColor;
#else
#define COMPAT_VARYING varying
#define FragColor gl_FragColor
#define COMPAT_TEXTURE texture2D
#endif

#ifdef GL_ES
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
#define COMPAT_PRECISION mediump
#else
#define COMPAT_PRECISION
#endif
COMPAT_VARYING     vec2 _input_dummy_tiles_per_texture;
COMPAT_VARYING     vec2 _tile_size_uv;
COMPAT_VARYING     vec2 _src_dxdy;
COMPAT_VARYING     vec2 _resize_magnification_scale;
COMPAT_VARYING     vec2 _tile_uv_wrap1;
COMPAT_VARYING     vec2 _src_tex_uv_wrap;
COMPAT_VARYING     float _frame_rotation;
struct input_dummy {
    vec2 _video_size;
    vec2 _texture_size2;
    vec2 _output_dummy_size;
    float _frame_count;
    float _frame_direction;
    float _frame_rotation;
};
struct out_vertex {
    vec2 _src_tex_uv_wrap;
    vec2 _tile_uv_wrap1;
    vec2 _resize_magnification_scale;
    vec2 _src_dxdy;
    vec2 _tile_size_uv;
    vec2 _input_dummy_tiles_per_texture;
};
vec4 _ret_0;
vec4 _TMP23;
vec4 _TMP22;
float _TMP30;
float _TMP29;
float _TMP28;
float _TMP27;
vec4 _TMP21;
vec2 _TMP25;
vec2 _TMP24;
float _TMP14;
float _TMP12;
float _TMP15;
float _TMP16;
uniform sampler2D Texture;
input_dummy _IN1;
float _TMP149;
float _v0240;
float _x0242;
int _samples0250;
float _input_dummy_tiles_per_texture_r0250;
float _tile_dr0250;
vec4 _weight_sum0250;
vec3 _pixel_color0250;
int _i10250;
vec4 _true_i10250;
vec4 _tile_uv_r10250;
vec4 _tex_uv_r10250;
vec4 _dist10250;
vec4 _pi_dist10250;
vec4 _pi_dist_over_lobes10250;
vec4 _weights10250;
vec2 _weight_sum_reduce0250;
vec3 _scalar_weight_sum0250;
vec2 _curr_texel0252;
vec2 _prev_texel0252;
vec2 _first_texel0252;
float _samples0252;
vec2 _first_texel_uv_wrap_2D0252;
vec2 _first_texel_dist_2D0252;
vec2 _first_texel_tile_uv_wrap_2D0252;
vec2 _coord_negative0252;
vec2 _first_texel_tile_uv_2D0252;
vec2 _tile_u_and_dist0252;
vec2 _x0254;
vec4 _x0258;
vec4 _TMP259;
vec2 _tex_uv0260;
vec4 _TMP263;
vec2 _tex_uv0264;
vec4 _TMP267;
vec2 _tex_uv0268;
vec4 _TMP271;
vec2 _tex_uv0272;
vec4 _a0276;
vec4 _a0298;
COMPAT_VARYING vec4 TEX0;
COMPAT_VARYING vec4 TEX1;
COMPAT_VARYING vec4 TEX2;
COMPAT_VARYING vec4 TEX3;
COMPAT_VARYING vec4 TEX4;
float _mask_min_allowed_tile_size;
float _max_sinc_resize_samples_float;
float _max_sinc_resize_samples_m4;
 
uniform int FrameDirection;
uniform int FrameCount;
uniform COMPAT_PRECISION vec2 OutputSize;
uniform COMPAT_PRECISION vec2 TextureSize;
uniform COMPAT_PRECISION vec2 InputSize;
void main()
{
    vec2 _src_tex_uv1;
    vec3 _pixel_color1;
    _TMP16 = min(2.00000000E+00, 0.00000000E+00);
    _TMP149 = max(0.00000000E+00, _TMP16);
    _TMP15 = floor(-1.60000000E+01);
    _mask_min_allowed_tile_size = -_TMP15;
    _max_sinc_resize_samples_float = 3.84000000E+02/_mask_min_allowed_tile_size;
    _v0240 = _max_sinc_resize_samples_float*2.50000000E-01;
    _x0242 = -_v0240;
    _TMP15 = floor(_x0242);
    _TMP12 = -_TMP15;
    _max_sinc_resize_samples_m4 = _TMP12*4.00000000E+00;
    _TMP14 = max(TEX1.x, TEX1.y);
    if (_TMP149 < 5.00000000E-01 && _TMP14 <= 2.00000000E+00) { 
        _src_tex_uv1 = fract(TEX0.xy);
        _samples0250 = int(_max_sinc_resize_samples_m4);
        _input_dummy_tiles_per_texture_r0250 = 1.00000000E+00/TEX4.x;
        _samples0252 = float(_samples0250);
        _curr_texel0252 = _src_tex_uv1*TextureSize;
        _x0254 = _curr_texel0252 - vec2( 4.99500006E-01, 4.99500006E-01);
        _TMP24 = floor(_x0254);
        _prev_texel0252 = _TMP24 + vec2( 5.00000000E-01, 5.00000000E-01);
        _first_texel0252 = _prev_texel0252 - vec2(_samples0252/2.00000000E+00 - 1.00000000E+00, _samples0252/2.00000000E+00 - 1.00000000E+00);
        _first_texel_uv_wrap_2D0252 = _first_texel0252*TEX3.x;
        _first_texel_dist_2D0252 = _curr_texel0252 - _first_texel0252;
        _first_texel_tile_uv_wrap_2D0252 = _first_texel_uv_wrap_2D0252*_input_dummy_tiles_per_texture_r0250;
        _coord_negative0252 = vec2(float((_first_texel_tile_uv_wrap_2D0252.x < 0.00000000E+00)), float((_first_texel_tile_uv_wrap_2D0252.y < 0.00000000E+00)));
        _TMP25 = fract(_first_texel_tile_uv_wrap_2D0252);
        _first_texel_tile_uv_2D0252 = _TMP25 + _coord_negative0252;
        _tile_u_and_dist0252 = vec2(_first_texel_tile_uv_2D0252.x, _first_texel_dist_2D0252.x);
        _tile_dr0250 = TEX3.x*_input_dummy_tiles_per_texture_r0250;
        _weight_sum0250 = vec4( 0.00000000E+00, 0.00000000E+00, 0.00000000E+00, 0.00000000E+00);
        _pixel_color0250 = vec3( 0.00000000E+00, 0.00000000E+00, 0.00000000E+00);
        _i10250 = 0;
        for (; _i10250 < _samples0250; _i10250 = _i10250 + 4) { 
            _true_i10250 = vec4(float(_i10250), float(_i10250), float(_i10250), float(_i10250)) + vec4( 0.00000000E+00, 1.00000000E+00, 2.00000000E+00, 3.00000000E+00);
            _x0258 = _tile_u_and_dist0252.xxxx + _true_i10250*_tile_dr0250;
            _tile_uv_r10250 = fract(_x0258);
            _tex_uv_r10250 = _tile_uv_r10250*TEX4.x;
            _tex_uv0260 = vec2(_tex_uv_r10250.x, _src_tex_uv1.y);
            _TMP259 = COMPAT_TEXTURE(Texture, _tex_uv0260);
            _tex_uv0264 = vec2(_tex_uv_r10250.y, _src_tex_uv1.y);
            _TMP263 = COMPAT_TEXTURE(Texture, _tex_uv0264);
            _tex_uv0268 = vec2(_tex_uv_r10250.z, _src_tex_uv1.y);
            _TMP267 = COMPAT_TEXTURE(Texture, _tex_uv0268);
            _tex_uv0272 = vec2(_tex_uv_r10250.w, _src_tex_uv1.y);
            _TMP271 = COMPAT_TEXTURE(Texture, _tex_uv0272);
            _a0276 = _tile_u_and_dist0252.yyyy - _true_i10250;
            _TMP21 = abs(_a0276);
            _dist10250 = TEX2.x*_TMP21;
            _pi_dist10250 = 3.14159274E+00*_dist10250;
            _pi_dist_over_lobes10250 = 1.04719758E+00*_dist10250;
            _TMP27 = sin(_pi_dist10250.x);
            _TMP28 = sin(_pi_dist10250.y);
            _TMP29 = sin(_pi_dist10250.z);
            _TMP30 = sin(_pi_dist10250.w);
            _TMP22 = vec4(_TMP27, _TMP28, _TMP29, _TMP30);
            _TMP27 = sin(_pi_dist_over_lobes10250.x);
            _TMP28 = sin(_pi_dist_over_lobes10250.y);
            _TMP29 = sin(_pi_dist_over_lobes10250.z);
            _TMP30 = sin(_pi_dist_over_lobes10250.w);
            _TMP23 = vec4(_TMP27, _TMP28, _TMP29, _TMP30);
            _a0298 = (_TMP22*_TMP23)/(_pi_dist10250*_pi_dist_over_lobes10250);
            _weights10250 = min(_a0298, vec4( 1.00000000E+00, 1.00000000E+00, 1.00000000E+00, 1.00000000E+00));
            _pixel_color0250 = _pixel_color0250 + _TMP259.xyz*_weights10250.xxx;
            _pixel_color0250 = _pixel_color0250 + _TMP263.xyz*_weights10250.yyy;
            _pixel_color0250 = _pixel_color0250 + _TMP267.xyz*_weights10250.zzz;
            _pixel_color0250 = _pixel_color0250 + _TMP271.xyz*_weights10250.www;
            _weight_sum0250 = _weight_sum0250 + _weights10250;
        } 
        _weight_sum_reduce0250 = _weight_sum0250.xy + _weight_sum0250.zw;
        _scalar_weight_sum0250 = vec3(_weight_sum_reduce0250.x + _weight_sum_reduce0250.y, _weight_sum_reduce0250.x + _weight_sum_reduce0250.y, _weight_sum_reduce0250.x + _weight_sum_reduce0250.y);
        _pixel_color1 = _pixel_color0250/_scalar_weight_sum0250;
        _ret_0 = vec4(_pixel_color1.x, _pixel_color1.y, _pixel_color1.z, 1.00000000E+00);
        FragColor = _ret_0;
        return;
    } else {
        discard;
    } 
    FragColor = _ret_0;
} 
#endif
